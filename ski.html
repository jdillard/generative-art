<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script>
        let tracks = [];
        let snowboarders = [];
        let time = 0;
        const MAX_SNOWBOARDERS = 2;

        class SnowboardTrack {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = random(width);
                this.y = -20;
                this.points = [];
                this.age = 0;
                this.maxAge = random(300, 500);
                this.width = random(8, 12);
                this.velocity = random(4, 6);
                this.angle = PI/2 + random(-0.6, 0.6);
                this.angleVelocity = 0;
                
                this.turnFrequency = random(0.004, 0.008);
                this.turnAmplitude = random(0.8, 1.2);
                this.waveOffset = random(1000);
                this.turnRadius = random(0.8, 1.4);
                
                // Track if this snowboarder should be removed
                this.shouldRemove = false;
            }

            constrainAngle(angle) {
                const minAngle = PI/4;
                const maxAngle = 3*PI/4;
                return Math.max(minAngle, Math.min(maxAngle, angle));
            }

            update() {
                this.x += cos(this.angle) * this.velocity;
                this.y += sin(this.angle) * this.velocity;

                let baseWave = sin((time * this.turnFrequency * 50) + this.waveOffset);
                let turnInfluence = baseWave * this.turnAmplitude;

                this.angleVelocity += turnInfluence * 0.03 * this.turnRadius;
                this.angleVelocity *= 0.93;
                
                this.angle += this.angleVelocity;
                this.angle = this.constrainAngle(this.angle);

                this.points.push({x: this.x, y: this.y, age: 0});

                this.age++;
                for (let p of this.points) {
                    p.age++;
                }

                this.points = this.points.filter(p => p.age < this.maxAge);

                // Mark for removal if off screen
                if (this.y > height + 20 || this.x < -20 || this.x > width + 20) {
                    this.shouldRemove = true;
                }
            }

            draw() {
                beginShape();
                noFill();
                
                for (let i = 0; i < this.points.length; i++) {
                    let p = this.points[i];
                    let alpha = map(p.age, 0, this.maxAge, 60, 0);
                    stroke(40, 40, 40, alpha);
                    strokeWeight(this.width);
                    vertex(p.x, p.y);
                }
                endShape();
            }
        }

        class SkiTrack {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = random(width);
                this.y = -20;
                this.points = [];
                this.age = 0;
                this.maxAge = random(200, 400);
                this.width = random(3, 6);
                this.spacing = random(15, 25);
                this.speed = random(3, 5);
                
                this.velocity = random(3, 5);
                this.angle = PI/2 + random(-0.6, 0.6);
                this.angleVelocity = 0;
                
                this.turnStyle = random();
                this.turnFrequency = random(0.002, 0.015);
                this.turnAmplitude = random(0.4, 1.2);
                
                this.preferredDirection = random() < 0.5 ? 
                    random(-0.6, -0.2) :
                    random(0.2, 0.6);
                    
                this.waveOffset = random(1000);
                this.turnRadius = random(0.6, 1.2);
            }

            constrainAngle(angle) {
                const minAngle = PI/4;
                const maxAngle = 3*PI/4;
                return Math.max(minAngle, Math.min(maxAngle, angle));
            }

            update() {
                this.x += cos(this.angle) * this.velocity;
                this.y += sin(this.angle) * this.velocity;

                let baseWave = sin((time * this.turnFrequency * 50) + this.waveOffset);
                
                let turnInfluence;
                if (this.turnStyle < 0.2) {
                    turnInfluence = baseWave * 0.15;
                } else if (this.turnStyle < 0.5) {
                    turnInfluence = baseWave * this.turnAmplitude * 0.6;
                } else if (this.turnStyle < 0.8) {
                    turnInfluence = baseWave * this.turnAmplitude * 0.8;
                } else {
                    let noiseInfluence = noise(this.x * 0.003, this.y * 0.003, time * 0.1) - 0.5;
                    turnInfluence = (baseWave * 0.7 + noiseInfluence) * this.turnAmplitude;
                }

                this.angleVelocity += turnInfluence * 0.025 * this.turnRadius;
                this.angleVelocity *= 0.93;
                
                this.angle += this.angleVelocity;
                this.angle = this.constrainAngle(this.angle);

                let targetAngle = PI/2 + this.preferredDirection;
                targetAngle = this.constrainAngle(targetAngle);
                this.angle = lerp(this.angle, targetAngle, 0.01);

                this.points.push({x: this.x, y: this.y, age: 0});

                this.age++;
                for (let p of this.points) {
                    p.age++;
                }

                this.points = this.points.filter(p => p.age < this.maxAge);

                if (this.y > height + 20 || this.x < -20 || this.x > width + 20) {
                    this.reset();
                }
            }

            draw() {
                for (let offset of [-this.spacing/2, this.spacing/2]) {
                    beginShape();
                    noFill();
                    
                    for (let i = 0; i < this.points.length; i++) {
                        let p = this.points[i];
                        let angle = i < this.points.length - 1 
                            ? atan2(this.points[i+1].y - p.y, this.points[i+1].x - p.x)
                            : this.angle;
                        let offsetX = cos(angle + PI/2) * offset;
                        let offsetY = sin(angle + PI/2) * offset;
                        
                        let alpha = map(p.age, 0, this.maxAge, 60, 0);
                        stroke(100, 100, 100, alpha);
                        strokeWeight(this.width);
                        
                        vertex(p.x + offsetX, p.y + offsetY);
                    }
                    endShape();
                }
            }
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            background(250);
            
            // Create initial tracks
            for (let i = 0; i < 5; i++) {
                tracks.push(new SkiTrack());
            }
            
            // Start with random number of snowboarders (0 to 2)
            let initialSnowboarders = floor(random(MAX_SNOWBOARDERS + 1));
            for (let i = 0; i < initialSnowboarders; i++) {
                snowboarders.push(new SnowboardTrack());
            }
        }

        function draw() {
            background(250, 20);
            
            // Add subtle snow texture
            for (let i = 0; i < 10; i++) {
                stroke(255);
                strokeWeight(random(1, 2));
                point(random(width), random(height));
            }
            
            // Update and draw ski tracks
            for (let track of tracks) {
                track.update();
                track.draw();
            }
            
            // Update and draw snowboarders
            for (let snowboarder of snowboarders) {
                snowboarder.update();
                snowboarder.draw();
            }
            
            // Remove finished snowboarders
            snowboarders = snowboarders.filter(s => !s.shouldRemove);
            
            // Randomly add new snowboarders with varying gaps
            if (snowboarders.length < MAX_SNOWBOARDERS) {
                // More likely to add a snowboarder when there are none
                let spawnChance = snowboarders.length === 0 ? 0.02 : 0.01;
                if (random() < spawnChance) {
                    snowboarders.push(new SnowboardTrack());
                }
            }
            
            time += 0.01;
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            background(250);
        }
    </script>
</body>
</html>
