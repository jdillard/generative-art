<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script>
        let tracks = [];
        let time = 0;

        class SkiTrack {
            constructor() {
                this.reset();
            }

            reset() {
                // Start from top of slope
                this.x = random(width);
                this.y = -20;
                // Track properties
                this.points = [];
                this.age = 0;
                this.maxAge = random(200, 400);
                this.width = random(3, 6);
                this.spacing = random(15, 25);
                this.speed = random(3, 5);
                
                // Movement properties
                this.velocity = random(3, 5);
                this.angle = PI/2 + random(-0.6, 0.6);
                this.angleVelocity = 0;
                
                // Increased turn characteristics
                this.turnStyle = random();
                this.turnFrequency = random(0.002, 0.015); // Increased frequency range
                this.turnAmplitude = random(0.4, 1.2);     // Increased amplitude range
                
                // Random initial direction
                this.preferredDirection = random() < 0.5 ? 
                    random(-0.6, -0.2) :  // Left bias
                    random(0.2, 0.6);     // Right bias
                    
                // Sine wave offset for organic movement
                this.waveOffset = random(1000);
                
                // New property for dynamic turn radius
                this.turnRadius = random(0.6, 1.2);
            }

            // Constrain an angle to ensure downward movement
            constrainAngle(angle) {
                const minAngle = PI/4;     // 45 degrees
                const maxAngle = 3*PI/4;   // 135 degrees
                return Math.max(minAngle, Math.min(maxAngle, angle));
            }

            update() {
                // Update position
                this.x += cos(this.angle) * this.velocity;
                this.y += sin(this.angle) * this.velocity;

                // Calculate turning based on individual style with increased waviness
                let baseWave = sin((time * this.turnFrequency * 50) + this.waveOffset);
                
                let turnInfluence;
                if (this.turnStyle < 0.2) {
                    // Straight-line skier: minimal turning but still some waviness
                    turnInfluence = baseWave * 0.15;
                } else if (this.turnStyle < 0.5) {
                    // Smooth, regular turns with increased amplitude
                    turnInfluence = baseWave * this.turnAmplitude * 0.6;
                } else if (this.turnStyle < 0.8) {
                    // Wide, sweeping turns
                    turnInfluence = baseWave * this.turnAmplitude * 0.8;
                } else {
                    // Dynamic, varied turns
                    let noiseInfluence = noise(this.x * 0.003, this.y * 0.003, time * 0.1) - 0.5;
                    turnInfluence = (baseWave * 0.7 + noiseInfluence) * this.turnAmplitude;
                }

                // Apply turn influence with increased magnitude
                this.angleVelocity += turnInfluence * 0.025 * this.turnRadius;
                this.angleVelocity *= 0.93; // Slightly reduced damping for more fluid turns
                
                // Update and constrain angle
                this.angle += this.angleVelocity;
                this.angle = this.constrainAngle(this.angle);

                // Gentler bias towards preferred direction
                let targetAngle = PI/2 + this.preferredDirection;
                targetAngle = this.constrainAngle(targetAngle);
                this.angle = lerp(this.angle, targetAngle, 0.01); // Reduced lerp factor

                // Add current position to track
                this.points.push({x: this.x, y: this.y, age: 0});

                // Age the track
                this.age++;
                for (let p of this.points) {
                    p.age++;
                }

                // Remove old points
                this.points = this.points.filter(p => p.age < this.maxAge);

                // Reset if track is too old or off screen
                if (this.y > height + 20 || this.x < -20 || this.x > width + 20) {
                    this.reset();
                }
            }

            draw() {
                // Draw parallel ski tracks
                for (let offset of [-this.spacing/2, this.spacing/2]) {
                    beginShape();
                    noFill();
                    
                    for (let i = 0; i < this.points.length; i++) {
                        let p = this.points[i];
                        // Calculate perpendicular offset for parallel tracks
                        let angle = i < this.points.length - 1 
                            ? atan2(this.points[i+1].y - p.y, this.points[i+1].x - p.x)
                            : this.angle;
                        let offsetX = cos(angle + PI/2) * offset;
                        let offsetY = sin(angle + PI/2) * offset;
                        
                        // Calculate opacity based on age
                        let alpha = map(p.age, 0, this.maxAge, 60, 0);
                        stroke(100, 100, 100, alpha);
                        strokeWeight(this.width);
                        
                        vertex(p.x + offsetX, p.y + offsetY);
                    }
                    endShape();
                }
            }
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            background(250);
            
            // Create initial tracks
            for (let i = 0; i < 5; i++) {
                tracks.push(new SkiTrack());
            }
        }

        function draw() {
            // Refresh background with slight fade
            background(250, 20);
            
            // Add subtle snow texture
            for (let i = 0; i < 10; i++) {
                stroke(255);
                strokeWeight(random(1, 2));
                point(random(width), random(height));
            }
            
            // Update and draw tracks
            for (let track of tracks) {
                track.update();
                track.draw();
            }
            
            time += 0.01;
        }

        // Handle window resizing
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            background(250);
        }
    </script>
</body>
</html>
